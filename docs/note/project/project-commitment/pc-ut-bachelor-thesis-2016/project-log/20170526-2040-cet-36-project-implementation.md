* This is a draft for my project implementation.
* I think in this chapter I need to explain hw the project went.
    * Or, should I do this?
    * I am not sure on if personal experience matter in research paper.
* I used Arduino MEGA and Raspberry PI to make prototype for this project deliverable.
* For this project, I will not go deep to explain the electronics technicalities.
* This will be more into how to program the electronics development platform to satisfy this project's needs.
* Arduino is the lowest entry point for electronics development platform. There are two kinds of Arduino those I think would be a fit for this project: Arduino UNO and Arduino MEGA.
* Most of the time, for DIY electronics project, Arduino UNO is well enough. Personally, the reason to use the MEGA variant if the projects need more input and output pins as well as large on-board memory to store more codes.
* Arduino UNO/MEGA offers a user friendly development approach. As it is a mature open source project, Arduino UNO/MEGA comes with a lot of options to extended for both codes and for the physical hardware. Hence, Arduino UNO/MEGA is commonly used as development platform to kick-start electronics project.
* Arduino is the lowest entry point for electronics development platform. There are many kinds of Arduino.
* Arduino UNO is one of the entry point when people usually start using Arduino.
* Arduino MEGA goes next for people that needs to store more codes and to have many more in and out pins.
* Arduino NANO variant is what people goes if smaller form is matter and foot print is not important. It serves the same specifications with Arduino UNO but nearly a fourth the size.
    * If footprints matter though, usually people (my friends) goes with dis-attaching the ATMega chip on the Arduino UNO and then re-create concise PCB.
    * In that case, schematics matter.
* Draft, I assumed that this will be really bad. I write this in hurry.
    * Based from my experience, trouble comes when the project started to get bigger. The use of third party library sometimes left unnecessary footprints. This causes the codes to take more spaces. On the other hand, Arduino especially the UNO variant has only 32 kilobytes to store codes, while the MEGA variant offers eight times more storage for codes than Arduino UNO. So, if Arduino project programmed with more than two libraries used, it might be good to start off using Arduino MEGA.
    * For this project, I tried to use Arduino UNO to make the first iteration. Making an independent wearable sensor device is not possible with Arduino since the lack of static storage (can be extended with SD Card reader but that significantly increases codes size) and processing power. The problem was realized when I need to take data from multiple sensors, filter the data, and send it to database with specific tagging. The tagging will be the an identification string and a real-world time stamp. This result in in multiple operations need to be done independently: time counter needs to be increased for every sample time passed in real-world (in this scenario it was a second), while keep waiting for data from sensor, as well as to sent data to database wireless.
    * For the timer I used the classic 555 timer chip to have the system take data regularly and to tag it with time stamp. There is other option that might a better fit for this situation, which is a real-world clock chip from Maxim Integrated. It has library for easy interface with Arduino as well.
    * The filter is very simple. In essence the system will not bother on very low value comes from the sensor. Since, raw sensor valued always from 0 to 1023, there is a necessity to convert the value into more human comprehensible value.
    * When I was developing with Arduino I used ESP8266 to sent data to simple web server and then to database over WiFi. However there was a problem of which these operations are not in sync to each other. The case was, when timer is ready, it asks sensor to capture incoming input, if there is a connectivity delay from the ESP8266 the options are either to buffer the data or to discard the data before the database input. The latter is not preferable. The former made the buffer grow larges. Additionally, because data input to the database need to be confirmed back to each clients, the process sometimes took longer than the sample time, hence the sensors misses its interval to capture data.
    * From my development time using Arduino. I concluded that for a project like this, where a lot of operations should happened independently to each other and not stacked together into a single thread, having access to multi-threaded programming can make the development process easier.
    * I decided to re-make the whole application back with Raspberry PI. The use of full featured Linux operating system make the development process easier. One can just develop a Linux application and then run it in Raspberry PI without little to no adjustment necessary. Raspberry PI uses Python as a programming language to interface with its input and output pins. A fresh install of Raspbian Linux includes Python library to interface with hardware easily.
    * My approach was to program everything as possible without the Raspberry PI itself. Started to program face detection using OpenCV and then audio pitch and volume detection using Aubio and Alsa. All libraries have a Python wrapper. However, the use of Alsa to interface audio input is so specific to Linux. Hence, I decided to change Alsa with higher level library so the pitch and volume detection can be in other operating system as well. The replacement of Alsa is PyAudio, which is a very extensive library to interface audio input and output.
    * After I done with programming for the multi-modal sensor, I went to establish database connection. There are a lot of choices for database. The obvious one is to use SQL based database. SQL is the latent database that most people know. However, as suggested in __*(please put reference from Carthal Gurrin paper here, I think he says something on why NOSQL database is better to use than using SQL variant)*__ using SQL database for social data gathering limits the potential of adding additional information. Real-life social interactivity can be determined with less or more informations and not strictly to the amount that previously defined in the SQL scheme. This concept suggest me to use NOSQL database. Basically, NOSQL database is a recently popular variant of database that is not strict to a scheme. To some sense, NOSQL database is just a collection of documents formatted like JSON or Python's dict. There are two options I looked for this project's database: MongoDB and RethinkDB. I decided to use the latter because this project aims to have real-time information operation, of which what RethinkDB is promised. The nature of NOSQL database to be inputted arbitrarily benefit this project, since the data from sensor can be easily added or removed.
    * The web server done with Python's Flask. Flask is a minimal web library to establish web server a fast as possible. This project will not have a particular attention on developing web server itself. Since the web server is only used to let user to view what are inside the database (public API), a simple minimalistic library like Flask fits the needs. For web client I try to implement a visualization based on D3JS.
    * The latest programming I did before making the case was developing the context-given-agent. In this case I got myself two infrared LEDs and two infrared receiver. The circuitry is simple, each needs the infrared transceiver, a 10K Ohm resistor, and an NPN transistor. I used LIRC library to interface this self-made infrared transceiver.
* The hurdles was when transferring the whole codes into Raspbian, the Raspberry PI official operating system. To get access to hardware, correct permissions need to be given. This is common security measure for any operating systems. In Raspbian, there are two default users: root and pi. root has the privilege of being super user. Being super users allow all possible modifications to the operating system, this includes hardware access. The default pi user, on the other hand, has limited access, unless specific permission is given by `sudo`. `sudo` refers to `su` and `do`. It gives normal privileged user to execute command on behalf of super user. The development was not pleasant due to I did not know what is the best practices. Then, I decided to set and run the codes with super user privilege, hence giving all hardware access. This is not the ideal situation, since imposing an application with super user privilege is the same with letting anyone goes in and out through your house. However, I found that this practice is suitable for development purpose.uitable for development purpose.