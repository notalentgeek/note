![./20170325-1435-cet-introduction-1.png](./20170325-1435-cet-introduction-1.png)

* Human has talent for social and spatial reasonining.
* Computer capable of doing manipulation of meaningless data.

![./20170325-1435-cet-introduction-2.png](./20170325-1435-cet-introduction-2.png)

* There is no "state of the art" way to have communication between human and computer.
* At that point communication is specifically made for a purpose from scratch.
* There is no mediator that connnects between human computer.
* Here is the reason why there are 3 kinds of programming language.
	* The high level programming language, that is nearly similar to human language. For example, Java, JavaScript, ....
	* The medium level programming language, that resides in the middle between high level programming language and low level programming language. This kind of programming language capable of doing human - language level of operation as well as machine language level operation (accessing memory, defining memory allocation, ...). The example of this programming language is the C variants, except for C# that is more similar to Java than any other C variants.
	* The low level languages are solely speak machine language. The example of these programming languages are Assembly and Machine Code.
* Here is StackOverflow discussion about "level" in programming language, [http://stackoverflow.com/questions/3468068/low-mid-high-level-language-whats-the-difference](http://stackoverflow.com/questions/3468068/low-mid-high-level-language-whats-the-difference).
* Here is the screenshot.

![./20170325-1435-cet-introduction-3.png](./20170325-1435-cet-introduction-3.png)

![./20170325-1435-cet-introduction-4.png](./20170325-1435-cet-introduction-4.png)

* Human language is not grammatically strict.
* This means that human can speak with wrong grammar and people will still understand it.
* On the other hand, computer/machine language is grammatically strict.
* However, it says in here that both of human language and computer/machine language follow a same principle.
* I just do not know what is the principle meant in this screenshot.

![./20170325-1435-cet-introduction-5.png](./20170325-1435-cet-introduction-5.png)

![./20170325-1435-cet-introduction-6.png](./20170325-1435-cet-introduction-6.png)

* Casual computing activity refer to computing activity with graphical user interfaces.
* For example non - casual computing activity will be programming with programming language.
* The hardcore, computing activity will be to programming computer machine directly by allocating its memory blocks manually.
* So, the more user interface available for the human the more casual computing activity it is.

![./20170325-1435-cet-introduction-7.png](./20170325-1435-cet-introduction-7.png)

* Usually in more flexible operating system, for example in desktop operating system like, Linux, MacOs, or Windows every users can still do the non - casual computing to hardcore computing if they know what and where to set the environment.
* One example of good non - casual "tool" for computing activity is JavaScript.
* JavaScript is exists in almost every web browser.
* This means that JavaScript is exists in about every consumer device.

![./20170325-1435-cet-introduction-8.png](./20170325-1435-cet-introduction-8.png)

* The problem with programming is that the programmer often get lost in their own maze.
* Programmers often feel alienated from the program that they are making.

![./20170325-1435-cet-introduction-9.png](./20170325-1435-cet-introduction-9.png)

* Learning is a hard work.

![./20170325-1435-cet-introduction-10.png](./20170325-1435-cet-introduction-10.png)

* Computer programmer can built universe with nearly unlimited possible combinations.
* Although, there will still be limitations right and left.
* The screenshot is from Joseph Weizenbaum, from his book titled "Computer Power And Human Reason."
* Here is the link to the book, [http://blogs.evergreen.edu/cpat/files/2013/05/Computer-Power-and-Human-Reason.pdf](http://blogs.evergreen.edu/cpat/files/2013/05/Computer-Power-and-Human-Reason.pdf).
* Here is the .pdf of the book.

[./20170325-1435-cet-introduction-11.pdf](./20170325-1435-cet-introduction-11.pdf)

![./20170325-1435-cet-introduction-12.png](./20170325-1435-cet-introduction-12.png)

* There is no proper analogy to compare computer program with any physical real - life things.

![./20170325-1435-cet-introduction-13.png](./20170325-1435-cet-introduction-13.png)

* Computer is a machine that capable to host these immaterial machines.
* These immaterial machine refers to simple memory allocation operation of computing activities.

![./20170325-1435-cet-introduction-14.png](./20170325-1435-cet-introduction-14.png)

* Computing is used to execute simple task with incredibly high speed.
* However, this simple task can be stacked with other simple task to construct near infinite possible operations.

![./20170325-1435-cet-introduction-15.png](./20170325-1435-cet-introduction-15.png)

![./20170325-1435-cet-introduction-16.png](./20170325-1435-cet-introduction-16.png)

* Keeping codes under control is a programmer's bane.

![./20170325-1435-cet-introduction-17.png](./20170325-1435-cet-introduction-17.png)

* The programming is actually the art of controlling complexity.

![./20170325-1435-cet-introduction-18.png](./20170325-1435-cet-introduction-18.png)

![./20170325-1435-cet-introduction-19.png](./20170325-1435-cet-introduction-19.png)

* There are a lot way to do stuffs in programming.
* However, as it is mentioned here, programmers tend to stick in a way.
* Sometimes, any programmers who would like to think out side of the box from their codes will be outcast and labeled as a "bad programmer".

![./20170325-1435-cet-introduction-20.png](./20170325-1435-cet-introduction-20.png)

* Programming is an ever updated profession.
* One needs to keep exploring and learning on the possible new technology.

![./20170325-1435-cet-introduction-21.png](./20170325-1435-cet-introduction-21.png)

![./20170325-1435-cet-introduction-22.png](./20170325-1435-cet-introduction-22.png)

* Example of the earliest low level programming languages.

![./20170325-1435-cet-introduction-23.png](./20170325-1435-cet-introduction-23.png)

* But then people starting to understand that it could be made more humane.

![./20170325-1435-cet-introduction-24.png](./20170325-1435-cet-introduction-24.png)

* And then there is an incentive to name a memory block. This is then what it is now variable.

![./20170325-1435-cet-introduction-25.png](./20170325-1435-cet-introduction-25.png)

* `if`, `while`, ... are an example of programming construct.
* These already set as a set of operations in lower level language.

![./20170325-1435-cet-introduction-26.png](./20170325-1435-cet-introduction-26.png)

![./20170325-1435-cet-introduction-27.png](./20170325-1435-cet-introduction-27.png)

* Every number that you put in a statement will "technically" construct a variable.
* You could see that as `compare` variable in an example from above screeshot.

![./20170325-1435-cet-introduction-28.png](./20170325-1435-cet-introduction-28.png)

* Programming language defines a lot of uninteresting details of programming for higher level developer to program.

![./20170325-1435-cet-introduction-29.png](./20170325-1435-cet-introduction-29.png)

* Example of the shortest definition of loop in the most concise operation possible.

![./20170325-1435-cet-introduction-30.png](./20170325-1435-cet-introduction-30.png)

* To sum up, program can be made in any way possible, from long to short, from unreadable into readable.

![./20170325-1435-cet-introduction-31.png](./20170325-1435-cet-introduction-31.png)

* JavaScript has nothing to do with Java.
* Java was first and then JavaScipt came.
* At the time when JavaScript is invented Java was (I think), the most popular programming language.
* Thus, JavaScript developer wants to bandwagon their creation to Java.
* Hence, the name JavaScript.

![./20170325-1435-cet-introduction-32.png](./20170325-1435-cet-introduction-32.png)

* JavaScript and ECMAScript is the same.

![./20170325-1435-cet-introduction-33.png](./20170325-1435-cet-introduction-33.png)

![./20170325-1435-cet-introduction-34.png](./20170325-1435-cet-introduction-34.png)

![./20170325-1435-cet-introduction-35.png](./20170325-1435-cet-introduction-35.png)

![./20170325-1435-cet-introduction-36.png](./20170325-1435-cet-introduction-36.png)

* JavaScript is very liberal programming language.
* JavaScript has low entry point for beginner.
* However, as your project grows it will getting significantly harder to manage your code.

![./20170325-1435-cet-introduction-37.png](./20170325-1435-cet-introduction-37.png)

* The upcoming JavaScript is the ECMAScript 6 JavaScript that will be updated soon enough. There are several web browsers those already apply ECMAScript partially.

![./20170325-1435-cet-introduction-38.png](./20170325-1435-cet-introduction-38.png)

* Web browsers is not the only platforms in JavaScript.
* Some database like MongoDB and CouchDB use JavaScript as their programming and query language.

![./20170325-1435-cet-introduction-39.png](./20170325-1435-cet-introduction-39.png)

* NodeJS capable of doing system level operation through JavaScript codes.
* Although, NodeJS itself is built with C++ back - end.

![./20170325-1435-cet-introduction-40.png](./20170325-1435-cet-introduction-40.png)

* Please consider active learning when learning everything.
* Try to practice the theory.
* This may slow, but you will get easier learning the next similar thing you want to learn.

![./20170325-1435-cet-introduction-41.png](./20170325-1435-cet-introduction-41.png)

* Do not assume you are understand before you are doing the solution by yourself.

![./20170325-1435-cet-introduction-42.png](./20170325-1435-cet-introduction-42.png)

* As well as do not forget to exercise.

![./20170325-1435-cet-introduction-43.png](./20170325-1435-cet-introduction-43.png)

* There is a source code for everything those are listed in this book.

![./20170325-1435-cet-introduction-44.png](./20170325-1435-cet-introduction-44.png)

![./20170325-1435-cet-introduction-45.png](./20170325-1435-cet-introduction-45.png)

* These are the overview of the book.
* There will be a chapter where I asked to develop myself these things.
	* Artificial life simulator.
	* Dynamic website.
	* Pain program.
	* Platformer video game.
	* Programming language.

![./20170325-1435-cet-introduction-46.png](./20170325-1435-cet-introduction-46.png)

![./20170325-1435-cet-introduction-47.png](./20170325-1435-cet-introduction-47.png)

* I am wondering what they meant by creating abstract codes?
* It says here that the more abstract your code is, the more control you have over the codes you made.

![./20170325-1435-cet-introduction-48.png](./20170325-1435-cet-introduction-48.png)

![./20170325-1435-cet-introduction-49.png](./20170325-1435-cet-introduction-49.png)

![./20170325-1435-cet-introduction-50.png](./20170325-1435-cet-introduction-50.png)

* There is a chapter about error handling and fixing as well.
* And regular expression.
* Regular expression is the best way to do string manipulation.
* I wanted to learn this, but I saw there is a ton of specifics syntax to selecting and modifying text, hence I cowered up.

![./20170325-1435-cet-introduction-51.png](./20170325-1435-cet-introduction-51.png)

![./20170325-1435-cet-introduction-52.png](./20170325-1435-cet-introduction-52.png)

* Modularity is another example on writing clean codes.

![./20170325-1435-cet-introduction-53.png](./20170325-1435-cet-introduction-53.png)

* Overall structure of the book.